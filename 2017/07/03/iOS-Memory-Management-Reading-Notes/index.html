<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Calvin 的个人主页，主要记录技术、读书、投资理财等相关内容，座右铭：Stay hungry Stay foolish.">
    <meta name="keyword" content="技术、读书、思考、成长、理财、投资、管理">
    <meta name="referrer" content="no-referrer">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
            iOS 内存管理 - DHTalk&#39;s Blog | Stay hungry Stay foolish.
                
    </title>

    <link rel="canonical" href="https://zhangdinghao.cn/2017/07/03/iOS-Memory-Management-Reading-Notes/">

    <!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) -->
    <script src="https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js"></script>
    <!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 -->

    <!-- Custom Card JavaScript -->
    <script src="/js/card.js"></script>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>

<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">DHTalk&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                        
                    
                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    
                        
                        <li>
                            <a href="/archive/">Archives</a>
                        </li>
                        
                    
                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                        
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#ObjC" title="ObjC">ObjC</a>
                        
                    </div>
                    <h1>iOS 内存管理</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by Calvin on
                        2017-07-03
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h3 id="什么是自动引用计数-ARC"><a href="#什么是自动引用计数-ARC" class="headerlink" title="什么是自动引用计数(ARC)"></a>什么是自动引用计数(ARC)</h3><blockquote>
<p>在 Objective-C 中采用 <code>Automatic Reference Counting (ARC)</code> 机制，让编译器来进行内存管理。在新一代 Apple LLVM 编译器中设置ARC为有效状态，就无需再次键入<code>retain</code>或者<code>release</code>代码，这在降低程序崩溃、内存泄漏等风险的问时，很大程度上减少了开发程序的工作量。编译器完全清楚目标对象，并能立刻释放那些不再被使用的对象。如此一来，应用程序将具有可预测性，且能流畅运行，速度也将大幅提升。</p>
</blockquote>
<a id="more"></a>
<h4 id="苹果的实现"><a href="#苹果的实现" class="headerlink" title="苹果的实现"></a>苹果的实现</h4><p>NSObject 类的源代码没有公开，此处利用 Xcode 的调试器和 iOS 大概追溯出其实现过程。</p>
<p>在 NSObject 类的 alloc 类方法上设置断点，追踪程序的执行。以下列出了执行所调用的方法和函数。</p>
<ul>
<li>+alloc</li>
<li>+allocWithZone:</li>
<li>class_createlnstance</li>
<li>calloc</li>
</ul>
<p>alloc 类方法首先调用 allocWithZone: 类方法，然后调用 <code>class_
createlnstance</code> 函数，最后通过调用 <code>calloc</code> 来分配内存块。<code>class_createlnstance</code> 函数的源代码可以通过 <code>objc4</code> 库中的 <code>runtime/objc-runtime-new.mm</code> 进行确认。</p>
<p><code>retainCount/retain/release</code> 实例方法又是怎样实现的呢？同刚才的方法一样，下面列出各个方法分别调用的方法和函数。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-retainCount</div><div class="line">_CFDoExternRefOperation</div><div class="line"><span class="built_in">CFBasicHashGetCountOfKey</span></div><div class="line"></div><div class="line">-<span class="keyword">retain</span></div><div class="line">_CFDoExternRefOperation</div><div class="line"><span class="built_in">CFBasicHashAddValue</span></div><div class="line"></div><div class="line">-release</div><div class="line">_CFDoExternRefOperation</div><div class="line"><span class="built_in">CFBasicHashRemoveValue</span></div><div class="line">(<span class="built_in">CFBasicHashRemoveValue</span> 返回 <span class="number">0</span> 时，-release 调用 dealloc )</div></pre></td></tr></table></figure>
<p>各个方法都通过同一个调用了 <code>_CFDoExternRefOperation</code> 函数，调用了一系列名称相似的函数。如这些函数名的前缀 “CF” 所示，它们包含于 <code>CoreFoundation</code> 框架源代码中，即是 <code>CFRuntime.c</code> 的 <code>_CFDoExternRefOperation</code> 函数。为了理解其实现，下面简化了<code>CFDoExternRefOperation</code> 函数后的源代码。</p>
<p><code>CF/CFRuntime.c</code> <code>_CFDoExternRefOperation</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> _CFDoExternRefOperation ( uintptr_t op, <span class="keyword">id</span> obj ) &#123;</div><div class="line"></div><div class="line"><span class="built_in">CFBasicHashRef</span> table = 取得对象对应的散列表(obj);</div><div class="line"><span class="keyword">int</span> count;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span>(op)&#123;</div><div class="line">        <span class="keyword">case</span> OPERATION_retainCount:</div><div class="line">        count = <span class="built_in">CFBasicHashGetCountOfKey</span>(table,obj);</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">        </div><div class="line">    <span class="keyword">case</span> OPERATION_retain:</div><div class="line">        <span class="built_in">CFBasicHashAddValue</span>(table,obj);</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    </div><div class="line">    <span class="keyword">case</span> OPERATION_release:</div><div class="line">        count = <span class="built_in">CFBasicHashRemoveValue</span>(table,obj);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span> == count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>_CFDoExtemRefOperation</code> 函数按 <code>retainCount/retain/release</code> 操作进行分发，调用不同的函数。NSObject 类的 <code>retainCount/retain/release</code> 实例方法也许如下面代码所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="built_in">NSUInteger</span>)retainCount</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="built_in">NSUInteger</span>) _CFDoExternRefOperation (OPERATION_retainCount, <span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">id</span>)<span class="keyword">retain</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>) _CFDoExternRefOperation (OPERATION_retain, <span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)release</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> _CFDoExternRefOperation(OPERATION_release, <span class="keyword">self</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以从 <code>_CFDoExternRefOperation</code> 函数以及由此函数调用的各个函数名看出，苹果的实现大概就是采用散列表（引用计数表）来管理引用计数。如图所示：</p>
<p><img src="/blogimg/20170703149905265688152.png" alt="20170703149905265688152.png"></p>
<p>通过引用计数表管理引用计数的好处如下:</p>
<ul>
<li>对象用内存块的分配无需考虑内存块头部。</li>
<li>引用计数表各记录中存有内存块地址，可从各个记录追溯到各对象的内存块。</li>
</ul>
<p>这里特别要说的是，第二条这一特性在调试时有着举足轻重的作用。即使出现故障导致对象占用的内存块损坏，但只要引用计数表没有被破坏，就能够确认各内存块的位置。如图所示：</p>
<p><img src="/blogimg/20170703149905287931529.png" alt="20170703149905287931529.png"></p>
<p>另外，在利用工具检测内存泄漏时，引用计数表的各记录也有助于检测各对象的持有者是否存在。</p>
<p>通过以上解说即可理解苹果的实现。</p>
<h3 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h3><p>autorelease 就是自动释放，这看上去很像 ARC，但实际上更类似于 C 语言中的自动变量的特性。</p>
<p>autorelease 会像 C 语言的自动变量那样来对待对象实例。当超出其作用域时，对象实例的 release 方法就会被调用。但和 C 语言的自动变量不同的是，程序员可以设定变量的作用域。</p>
<p>autorelease 具体使用方法如下：</p>
<ol>
<li>生成并持有 NSAutoreleasePool 对象</li>
<li>调用已分配对象的 autorelease 方法</li>
<li>废弃 NSAutoreleasePool 对象</li>
</ol>
<p><img src="/blogimg/20170626149845880678893.png" alt="20170626149845880678893.png"></p>
<p>NSAutoreleasePool 对象的生命周期相当于 C 语言变量的作用域。对于所有调用过 autorelease 实例方法的对象，在废弃 NSAutoreleasePool 对象时，都将调用 release 实例方法。</p>
<p>用源码表示如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc]init];</div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</div><div class="line">[obj autorelease];</div><div class="line">[pool drain];</div></pre></td></tr></table></figure>
<p>上述代码中的 <code>[pool drain]</code> 相当于 <code>[obj release]</code>。</p>
<p>在 <code>Cocoa</code> 框架中，相当于程序主循环的 <code>NSRunLoop</code> 或者在其他程序可运行的地方，对 <code>NSAutoreleasePool</code> 对象进行生成、持有和废弃处理。因此，程序开发者不一定非得使用 <code>NSAutoreleasePool</code> 对象进行开发工作。</p>
<p><img src="/blogimg/20170626149846494350491.png" alt="20170626149846494350491.png"></p>
<p>尽管如此，但在大量产生 <code>autorelease</code> 的对象时，只要不废弃 <code>NSAutoreleasePool</code> 对象，那么生成的对象就不能释放，因此有时会产生内存不足的现象。典型的例子是读入大量图像的同时改变其尺寸。图像文件读入到 <code>NSData</code> 对象，并从中生成 <code>UIImage</code> 对象，改变其尺寸后生成新的 <code>UIImage</code> 对象。这种情况下，就会大量产生 <code>autorelease</code> 对象。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; 图像数;++i)&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">    读入图像</div><div class="line">    大量产生 autorelease 的对象</div><div class="line">    由于没有废弃 NSAutoreleasePool 对象</div><div class="line">    最终导致内存不足</div><div class="line">    */</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在此情况下，有必要在适当的地方生成、持有或废弃 <code>NSAutoreleasePool</code> 对象。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; 图像数;++i)&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc]init];</div><div class="line">    <span class="comment">// 读入图像，大量产生 autorelease 的对象</span></div><div class="line">    </div><div class="line">    [pool drain];</div><div class="line">    </div><div class="line">    <span class="comment">// 通过 [pool drain]，autorelease 的对象被一起 release</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，<code>Cocoa</code> 框架中也有很多类似方法用于返回 <code>autorelease</code> 的对象。比如 <code>NSMutableArray</code> 类的 <code>arrayWithCapacity</code> 类方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> array = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">1</span>];</div></pre></td></tr></table></figure>
<p>此源代码等同于以下源代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> array = [[[<span class="built_in">NSMutableArray</span> alloc]initWithCapacity:<span class="number">1</span>] autorelease];</div></pre></td></tr></table></figure>
<h4 id="苹果的实现-1"><a href="#苹果的实现-1" class="headerlink" title="苹果的实现"></a>苹果的实现</h4><p>可通过 <code>objc4</code> 库的 <code>runtime/objc-arr.mm</code> 来确认苹果中 <code>autorelease</code> 的实现。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">class</span> AutoreleasePoolPage</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *push ()</div><div class="line">    &#123;</div><div class="line">        相当于生成或持有<span class="built_in">NSAutoreleasePool</span>类对象；</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *pop ( <span class="keyword">void</span> *token )</div><div class="line">    &#123;</div><div class="line">        相当于废弃<span class="built_in">NSAutoreleasePool</span>类对象；</div><div class="line">        releaseAll ();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> autorelease ( <span class="keyword">id</span> obj )</div><div class="line">    &#123;</div><div class="line">        相当于 `<span class="built_in">NSAutoreleasePool</span>` 类的 `addObject` 类方法</div><div class="line">        AutoreleasePoolPage *autoreleasePoolPage = 取得正在使用的AutoreleasePoolPage实例；</div><div class="line">        autoreleasePoolPage-&gt;add ( obj );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">id</span> *add (<span class="keyword">id</span> obj)</div><div class="line">    &#123;</div><div class="line">        将对象追加到内部数组中;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> releaseAll ()</div><div class="line">    &#123;</div><div class="line">        调用内部数组中对象的release实例方法；</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">void</span> *objc_autoreleasePoolPush(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push ();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> objc_autoreleasePoolPop (<span class="keyword">void</span> *ctxt)</div><div class="line">&#123;</div><div class="line">    AutoreleasePoolPage::pop (ctxt);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">id</span> *objc_autorelease(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> AutoreleasePoolPage::autorelease (obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>C++ 类中虽然有动态数组的实现，但其行为和 GNUstep 的实现完全相同。</p>
<p>我们使用调试器来观察一下 <code>NSAutoreleasePool</code> 类方法和 <code>autorelease</code> 方法的运行过程。如下所示，这些方法调用了关联于 <code>objc4</code> 库 <code>autorelease</code> 实现的函数。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line"><span class="comment">/* 等同于 objc_autoreleasePoolPush ( ) */</span></div><div class="line"></div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"></div><div class="line">[obj autorelease];</div><div class="line"><span class="comment">/* 等同于 objc_autorelease ( obj ) */</span></div><div class="line"></div><div class="line">[pool drain];</div><div class="line"><span class="comment">/* 等同于 objc_autoreleasePoolPop ( pool ) */</span></div></pre></td></tr></table></figure>
<p>另外，可通过 <code>NSAutoreleasePool</code> 类中的调试用非公开类方法 <code>showPools</code> 来确认己被 <code>autorelease</code> 的对象的状况。<code>showPools</code> 会将现在的 <code>NSAutoreleasePool</code> 的状况输出到控制台。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">[<span class="built_in">NSAutoreleasePool</span> showPools];</div></pre></td></tr></table></figure>
<p><code>NSAutoreleasePool</code> 类的 <code>showPools</code> 类方法只能在 iOS 中使用，作为替代，在现在的运行时系统中我们使用调试用非公开函数 _objc_autoreleasePoolPrint( )。</p>
<p><img src="/blogimg/20170703149905378046358.png" alt="20170703149905378046358.png"></p>
<hr>
<h4 id="提高调用Objective-C方法的速度"><a href="#提高调用Objective-C方法的速度" class="headerlink" title="提高调用Objective-C方法的速度"></a>提高调用Objective-C方法的速度</h4><p><code>GNUstep</code> 中的 <code>autorelease</code> 实际上是用一种特殊的方法来实现的。这种方法能够高效地运行0S X、iOS 用应用程序中频繁调用的 <code>autorelease</code> 方法，它被称为”IMP Caching”。</p>
<p>在进行方法调用时，为了解决类名/方法名以及取得方法运行时的函数指针，要在框架初始化时对其结果值进行缓存。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> autorelease_class = [<span class="built_in">NSAutoreleasePool</span> <span class="keyword">class</span>];</div><div class="line">SEL autorelease_sel = <span class="keyword">@selector</span>(addObject:);</div><div class="line">IMP autorelease_imp =[autorelease_class methodForSelector:autorelease_sel];</div></pre></td></tr></table></figure>
<p>实际的方法调用就是使用缓存的结果值。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="keyword">id</span> ) autorelease</div><div class="line">&#123;</div><div class="line">    (*autorelease_imp )( autorelease_class, autorelease_sel, <span class="keyword">self</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是 IMP Caching 的方法调用。虽然同以下源代码完全相同，但从运行效率上看，即使它依赖于运行环境，一般而言速度也是其他方法的2倍。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="keyword">id</span>)autorelease</div><div class="line">&#123;</div><div class="line">    [<span class="built_in">NSAutoreleasePool</span> addObject:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="autorelease-NSAutoreleasePool-对象"><a href="#autorelease-NSAutoreleasePool-对象" class="headerlink" title="autorelease NSAutoreleasePool 对象"></a>autorelease NSAutoreleasePool 对象</h4><p>提问：如果 autorelease NSAutoreleasePool 对象会如何？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line"></div><div class="line">[pool autorelease];</div></pre></td></tr></table></figure>
<p>回答：发生异常</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">*** Terminating app due to uncaught exception 'NSInvalidArgumentException'</div><div class="line"></div><div class="line">reason: '*** -(NSAutoreleasePool autorelease]:</div><div class="line">    Cannot autorelease an autorelease pool'</div></pre></td></tr></table></figure>
<p>通常在使用 Objective-C,也就是 Foundation 框架时，无论调用哪一个对象的 autorelease 实例方法，实现上是调用的都是 NSObject 类的 autorelease 实例方法。但是对于 NSAutoreleasePool 类，autorelease 实例方法已被该类重载，因此运行时就会出错。</p>
<hr>
<h3 id="ARC-规则"><a href="#ARC-规则" class="headerlink" title="ARC 规则"></a>ARC 规则</h3><p>实际上”引用计数式内存管理”的本质部分在 ARC 中并没有改变。就像”自动引用计数”这个名称表示的那样，ARC 只是自动地帮组我们处理”引用计数”部分。</p>
<h4 id="内存管理的思考方式"><a href="#内存管理的思考方式" class="headerlink" title="内存管理的思考方式"></a>内存管理的思考方式</h4><p>引用计数式内存管理的思考方式就是思考 ARC 所引起的变化。</p>
<ul>
<li>自己生成的对象，自己所持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>自己持有的对象不再需要时释放。</li>
<li>非自己持冇的对象无法释放。</li>
</ul>
<p>这一思考方式在ARC有效时也是可行的。只是在源代码的记述方法上稍有不同。</p>
<h4 id="所有权修饰符"><a href="#所有权修饰符" class="headerlink" title="所有权修饰符"></a>所有权修饰符</h4><p><code>Objective-C</code> 编程中为了处理对象，可将变量类型定义为 id 类型或各种对象类型。</p>
<p>所谓对象类型就是指向 NSObject 这样的 Objective-C 类的指针，例如 “NSObject<em>“。id 类型用于隐藏对象类型的类名部分，相当于 C 语言中常用的 “void </em>“。</p>
<p>ARC 环境时，id 类型和对象类型同 C 语言其他类型不同，其类型上必须附加所有权修饰符。</p>
<p>所有权修饰符一共有4种。</p>
<ul>
<li>_strong 修饰符</li>
<li>_weak 修饰符</li>
<li>_unsafe_unretained 修饰符</li>
<li>_autoreleasing 修饰符</li>
</ul>
<h5 id="strong修饰符"><a href="#strong修饰符" class="headerlink" title="_strong修饰符"></a>_strong修饰符</h5><p><code>_strong</code> 修饰符是 id 类型和对象类型默认的所有权修饰符。也就是说，以下源代码中的 id 变量，实际上被附加了所有权修饰符。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure>
<p>id 和对象类型在没有明确指定所有权修饰符时，默认为 <code>_strong</code> 修饰符。上面的源代码与以下相同。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> _<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure>
<p>该源码在 MRC 环境该如何表述呢？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* MRC */</span></div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure>
<p>该源代码一看则明，目前在表面上并没有任何变化。再看看下面的代码。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> _<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此源代码明确指定了 C 语言的变量的作用域。MRC 环境时，该源代码可记述如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* MRC */</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    [obj release];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了释放生成并持有的对象，增加了调用 <code>release</code> 方法的代码。该源代码进行的动作同先前 ARC 环境时的动作完全一样。</p>
<p>如此源代码所示，附有 <code>_strong</code> 修饰符的变量 obj 在超出其变量作用域时，即在该变量被废弃时，会释放其被赋予的对象。</p>
<p>如 “strong” 这个名称所示，<code>_strong</code> 修饰符表示对对象的 “强引用”。持有强引用的变量在超出其作用域时被废弃，随着强引用的失效，引用的对象会随之释放。</p>
<p>当然，附有 <code>__strong</code> 修饰符的变量之间可以相互赋值。</p>
<p>正如苹果宣称的那样，通过 <code>__strong</code> 修饰符，不必再次键入 <code>retain</code> 或者 <code>release</code>,完美地满足了 “引用计数式内存管理的思考方式”：</p>
<ul>
<li>自己生成的对象，自己所持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>不再需要自己持有的对象时释放。</li>
<li>非自己持有的对象无法释放。</li>
</ul>
<p>前两项“自己生成的对象，自己持有”和“非自己生成的对象，自己也能持有”只需通过对带<code>_strong</code> 的修饰符的变景赋值便可达成。通过废弃带 <code>_strong</code> 修饰符的变量（变量作用域结束或是成员变量所属对象废弃）或者对变量赋值，都可以做到“不再需要自己持有的对象时释放”。</p>
<p>最后一项“非自己持有的对象无法释放”，由于不必再次键入 <code>release</code>,所以原本就不会执行。这些都满足于引用计数式内存管理的思考方式。</p>
<p>因为 id 类型和对象类型的所有权修饰符默认为 <code>_strong</code> 修饰符，所以不需要写上 “__strong”。使ARC 环境及简单的编程遵循了 Objective-C 内存管理的思考方式。</p>
<h5 id="weak修饰符"><a href="#weak修饰符" class="headerlink" title="_weak修饰符"></a>_weak修饰符</h5><p>看起来好像通过 <code>_strong</code> 修饰符编译器就能够完美地进行内存管理。但是遗憾的是，仅通过 <code>_strong</code> 修饰符是不能解决有些重大问题的。</p>
<p>这里提到的重大问题就是引用计数式内存管理中必然会发生”循环引用”的问题。</p>
<p><img src="/blogimg/20170703149905469057068.png" alt="20170703149905469057068.png"></p>
<p>例如，前面出现的带有 <code>_strong</code> 修饰符的成员变量在持有对象时，很容易发生循环引用。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">©interface Test : <span class="built_in">NSObject</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> _<span class="keyword">strong</span> obj_;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> _<span class="keyword">strong</span>)obj;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></div><div class="line">-(<span class="keyword">id</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> _<span class="keyword">strong</span>)obj</div><div class="line">&#123;</div><div class="line">    obj_ = obj;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>以下为循环引用。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> test0 = [[Test alloc] init];</div><div class="line">    <span class="keyword">id</span> test1 = [[Test alloc] init];</div><div class="line">    [testO setObject:test1];</div><div class="line">    [test1 setObject:testO];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为便于理解，下面写出了生成并持有对象的状态。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">    *	test0持有Test对象A的强引用</div><div class="line">    */</div><div class="line">    <span class="keyword">id</span> test0 = [[Test alloc] init];<span class="comment">/*对象A */</span></div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">    *	test1持有Test对象B的强引用</div><div class="line">    */</div><div class="line">    <span class="keyword">id</span> test1 = [[Test alloc] init];<span class="comment">/*对象B */</span></div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">    * Test对象A的obj_成员变置持有Test对象B的强引用。</div><div class="line">    * 此时，持有Test对象B的强引用的变量为Test 对象 A 的 obj_和test1。</div><div class="line">    */</div><div class="line">    [test0 setObject:test1];</div><div class="line">    </div><div class="line">    <span class="comment">/*</span></div><div class="line">    * Test 对象 B 的 obj_ 成员变置持有 Test 对象 A 的强引用。</div><div class="line">    * 此时，持有 Test 对象 A 的强引用的变置为 Test 对象 B 的 obj_ 和test0。</div><div class="line">    */</div><div class="line">    [testl setObject:test0];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">* 因为 test0 变置超出其作用域，强引用失效,</div><div class="line">* 所以自动释放 Test 对象 A。</div><div class="line">* 因为 testl 变置超出其作用域，强引用失效,</div><div class="line">* 所以自动释放 Test 对象 B。</div><div class="line">* 此时，持有 Test 对象 A 的强引用的变置为 Test 对象 B 的 obj_。</div><div class="line">*</div><div class="line">* 此时，持有 Test 对象 B 的强引用的变置为 Test 对象 A 的 obj_。</div><div class="line">*</div><div class="line">* 发生内存泄漏！</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>循环引用容易发生内存泄漏。所谓内存泄漏就是应当废弃的对象在超出其生存周期后继续存在。此代码的本意是赋予变量 test0 的对象 A 和赋予变量 test1 的对象 B 在超出其变量作用域时被释放，即在对象不被任何变量持有的状态下予以废弃。但是，循环引用使得对象不能被再次废弃。</p>
<p>像下面这种情况，虽然只有一个对象，但在该对象持有其自身时，也会发生循环引用（自引用）。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> test = [[Test alloc] init];</div><div class="line">[test setObject:test];</div></pre></td></tr></table></figure>
<p>怎么样才能避免循环引用呢？看到 <code>_strong</code> 修饰符就会意识到了，既然有 <code>strong</code>,就应该有与之对应的 <code>weak</code>。也就是说，使用 <code>_weak</code> 修饰符可以避免循环引用。</p>
<p><code>_weak</code> 修饰符修饰符相反，提供弱引用。弱引用不能持有对象实例。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> _<span class="keyword">weak</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure>
<p>变景 obj 上附加了 <code>_weak</code> 修饰符。实际上如果编译以下代码，编译器会发出聱告，</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">warning: assigning retained obj to <span class="keyword">weak</span> variable; obj will be</div><div class="line">    released after assignment [-Ware-unsafe-retained-<span class="keyword">assign</span>]</div><div class="line">    <span class="keyword">id</span> _<span class="keyword">weak</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</div></pre></td></tr></table></figure>
<p>此源代码将自己生成并持有的对象赋值给附有 <code>_weak</code> 修饰符的变量 <code>obj</code>。即变量 <code>obj</code> 持有对持有对象的弱引用。因此，为了不以自己持有的状态来保存自己生成并持有的对象，生成的对象会立即被释放。编译器对此会给出警告。如果像下面这样，将对象赋值给附有 <code>_strong</code> 修饰符的变量之后再赋值给附有 <code>_weak</code> 修饰符的变量，就不会发生警告了。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> _<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">    <span class="keyword">id</span> _<span class="keyword">weak</span> obj1 = obj0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面确认对象的持有状况。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="comment">// 自己生成并持有对象</span></div><div class="line">    <span class="keyword">id</span> _<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc]init];</div><div class="line">    </div><div class="line">    <span class="comment">// 因为 obj0 变量为强引用，所以自己持有对象。</span></div><div class="line">    </div><div class="line">    <span class="comment">// obj1 变量持有生成对象的弱引用</span></div><div class="line">    <span class="keyword">id</span> _<span class="keyword">weak</span> obj1 = obj0;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">    因为 obj0 变量超出其作用域，强引用失效，所以自动释放其持有的对象。</div><div class="line">    因为对象的所有者不存在，所以废弃该对象。</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>因为带 <code>_weak</code> 修饰符的变量（即弱引用）不持有对象，所以在超出其变最作用域时，对象即被释放。如果像下面这样将先前可能发生循环引用的类成员变量改成附有 <code>_weak</code> 修饰符的成员变量的话，该现象便可避免。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Test</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> _<span class="keyword">weak</span> obj_;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> _<span class="keyword">strong</span>)obj;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><img src="/blogimg/20170703149906419276443.png" alt="20170703149906419276443.png"></p>
<p><code>_weak</code> 修饰符还有另一优点。在持有某对象的弱引用时，若该对象被废弃，则此弱引用将自动失效且处于nil 被赋值的状态（空弱应用）。如以下代码所示。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> _<span class="keyword">weak</span> obj1 = <span class="literal">nil</span>;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> _<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc]init];</div><div class="line">    objl = obj0;</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"A: %@"</span>, obj1);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"B: %@"</span>, obj1);</div></pre></td></tr></table></figure>
<p>此源代码执行结果如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">A: &lt;<span class="built_in">NSObject</span>: <span class="number">0x753e</span>l80&gt;</div><div class="line">B: (null)</div></pre></td></tr></table></figure>
<p>像这样，使用 <code>_weak</code> 修饰符可避免循环引用,通过检查附有 <code>_weak</code> 修饰符的变量是否为nil，可以判断被赋值的对象是否己废弃。</p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>在 ARC 的环境下编译源代码，必须遵守一定的规则。下由就是具体的 ARC 的规则</p>
<ol>
<li>不能使用 retain/release/retainCount/autorelease</li>
<li>不能使用 NSAllocateObject/NSDeallocateObject</li>
<li>须遵守内存管理的方法命名规则</li>
<li>不要显式调用 dealloc</li>
<li>使用 @autoreleasepool 块替代 NSAutoreleasePool</li>
<li>不能使用区域（NSZone)</li>
<li>对象型变量不能作为C语言结构体（struct/union)的成员</li>
<li>显式转换“id”和“void *”</li>
</ol>
<h4 id="不能使用-retain-release-retainCount-autorelease"><a href="#不能使用-retain-release-retainCount-autorelease" class="headerlink" title="不能使用 retain/release/retainCount/autorelease"></a>不能使用 retain/release/retainCount/autorelease</h4><p>内存管理是编译器的工作，因为没有必要使用内存管理的方法。</p>
<h4 id="不能使用-NSAllocateObject-NSDeallocateObject"><a href="#不能使用-NSAllocateObject-NSDeallocateObject" class="headerlink" title="不能使用 NSAllocateObject/NSDeallocateObject"></a>不能使用 NSAllocateObject/NSDeallocateObject</h4><p>一般通过调用 NSObject 类的 alloc 类方法来生成并持有 Objective-C 对象。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> alloc];</div></pre></td></tr></table></figure>
<p>但是就如 GNUstep 的 alloc 实现所示，实际上是通过直接调用 <code>NSAllocateObject</code> 函数来生成并持有对象的。</p>
<p>在 ARC 环境时，禁止使用 <code>NSAllocateObject</code> 函数。同 <code>retain</code> 等方法一样，如果使用便会引起编译错误。</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">error: 'NSAllocateObject is unavailable:</div><div class="line">not available in automatic reference counting mode</div></pre></td></tr></table></figure>
<p>同样地，也禁止使用用于释放对象的 <code>NSDeallocateObject</code> 函数。</p>
<h4 id="须遵守内存管理的方法命名规则"><a href="#须遵守内存管理的方法命名规则" class="headerlink" title="须遵守内存管理的方法命名规则"></a>须遵守内存管理的方法命名规则</h4><p>在 MRC 环境时，用于对象生成/持有的方法必须遵守以下的命名规则。</p>
<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
</ul>
<p>以上述名称开始的方法在返回对象时，必须返回给调用方所应当持有的对象。这在 ARC 环境时也一样，返回的对象完全没有改变。只是在 ARC 环境下要追加一条命名规则。</p>
<ul>
<li>init</li>
</ul>
<p>以 init 开始的方法的规则要比 <code>alloc/new/copy/mutableCopy</code> 更严格。该方法必须是实例方法，并且必须要返回对象。返回的对象应为 id 类型或该方法声明类的对象类型，抑或是该类的超类型或子类型。该返回对象并不注册到 <code>autoreleasepool</code> 上。基本上只是对 <code>alloc</code> 方法返回值的对象进行初始化处理并返回该对象。</p>
<p>以下为使用该方法的源代码。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc]init];</div></pre></td></tr></table></figure>
<p>如此源代码所示，init 方法会初始化 alloc 方法返回的对象，然后原封不动地返还给调用方。下面我们来看看以init开始的方法的命名规则。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="keyword">id</span>) initWithObject:(<span class="keyword">id</span>)obj;</div></pre></td></tr></table></figure>
<p>该方法声明遵守了命名规则，但下面这个方法虽然也以init开始，却没有返回对象，因此不能使用。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="keyword">void</span>) initThisObject;</div></pre></td></tr></table></figure>
<p>另外，下例虽然也是以 init 开始的方法但并不包含在上述命名规则里。请注意。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="keyword">void</span>) initialize;</div></pre></td></tr></table></figure>
<h4 id="不要显式调用-dealloc"><a href="#不要显式调用-dealloc" class="headerlink" title="不要显式调用 dealloc"></a>不要显式调用 dealloc</h4><p>无论 ARC 还是 MRC，只要对象的所有者都不持有该对象，该对象就被废弃。对象被废弃时，都会调用对象的 dealloc 方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 此处运行该对象被废弃时必须实现的代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 MRC 环境下必须像下面这样调用 [super dealloc]</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 此处运行该对象被废弃时必须实现的代码</span></div><div class="line">    [<span class="keyword">super</span> dealloc];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ARC 会自动对此进行处理，因此不必写 [super dealloc]。 </p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>在 ARC 环境下，Objective-C 类的属性也会发生变化。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) nsstring *name;</div></pre></td></tr></table></figure>
<p>在 ARC 环境下，以下可作为这种属性声明中使用的属性来用。</p>
<table>
<thead>
<tr>
<th>属性声明的属性</th>
<th>所有权修饰符</th>
</tr>
</thead>
<tbody>
<tr>
<td>assign</td>
<td>__unsafe_unretained 修饰符</td>
</tr>
<tr>
<td>copy</td>
<td>__strong修饰符(但是赋值的是被复制的对象)</td>
</tr>
<tr>
<td>retain</td>
<td>__strong 修饰符</td>
</tr>
<tr>
<td>strong</td>
<td>__strong 修饰符</td>
</tr>
<tr>
<td>unsafe_unretained</td>
<td>__unsafe_unretained 修饰符</td>
</tr>
<tr>
<td>weak</td>
<td>__weak 修饰符</td>
</tr>
</tbody>
</table>
<p>以上各种属性赋值给指定的属性中就相当于赋值给附加各属性对应的所有权修饰符的变量中。只有 <code>copy</code> 属性不是简单的斌值，它赋值的是通过 <code>NSCopying</code> 接口的<code>copyWithZone:</code> 方法复制赋值源所生成的对象。</p>
<p>另外，在声明类成员变量时，如果同属性声明中的属性不一致则会引起编译错误，比如下面这种情况。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> obj;</div></pre></td></tr></table></figure>
<p>在声明 id 型 obj 成员变量时，像下面这样，定义其属性声明为weak。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> obj;</div></pre></td></tr></table></figure>
<p>编译器出现如下错误。</p>
<figure class="highlight"><table><tr><td class="code"><pre><div class="line">error: existing ivar 'obj' for _weak property 'obj' must be _weak</div><div class="line">    @synthesize obj;</div><div class="line">    </div><div class="line">    note: property declared here</div><div class="line">    @property (nonatomic, weak) id obj;</div></pre></td></tr></table></figure>
<p>此时，成员变量的声明中需要附加 __weak 修饰符。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj;</div></pre></td></tr></table></figure>
<p>或者使用 <code>strong</code> 属性来代替 <code>weak</code> 属性。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, stong) <span class="keyword">id</span> obj;</div></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>以下是将附有 <code>_strong</code> 修饰符的变量作为静态数组使用的情况。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> objs[<span class="number">10</span>];</div></pre></td></tr></table></figure>
<p><code>_weak</code> 修饰符，<code>_autoreleasing</code> 修饰符以及 <code>_unsafe_unretained</code> 修饰符也与此相同。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> _<span class="keyword">weak</span> objs[<span class="number">10</span>];</div></pre></td></tr></table></figure>
<p><code>_unsafe_unretained</code> 修饰符以外的 _strong/_weak/ autorelcasing修饰符保证其指定的变量初始化为 nil。同样地，附有 _strong/_weak/_autoreleasing 修饰符变量的数组也保证其初始化为 nil。下面我们就来看看数组中使用附有 _strong 修饰符变量的例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> objs[<span class="number">2</span>];</div><div class="line"></div><div class="line">    objs[<span class="number">0</span>] = [[<span class="built_in">NSObject</span> alloc]init];</div><div class="line">    objs[l] = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>数组超出其变量作用域时，数组中各个附有 <code>_strong</code> 修饰符的变量也随之失效，其强引用消失，所赋值的对象也随之释放。这与不使用数组的情形完全一样。</p>
<p>将附有 _strong 修饰符的变量作为动态数组来使用时又如何呢？在这种情况下，根据不同的目的选择使用 NSMutableArray、NSMutableDictionary、NSMutableSet 等 Foundation 框架的容器。这些容器会恰当地持有追加的对象并为我们管理这些对象。</p>
<p>像这样使用容器虽然更为合适，但在 C 语言的动态数组中也可以使用附有 <code>_strong</code> 修饰符的变量，只是必须要遵守一些事项。以下按顺序说明。</p>
<p>声明动态数组用指针。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">id</span> _<span class="keyword">strong</span> *array = <span class="literal">nil</span>;</div></pre></td></tr></table></figure>
<p>如前所述，由于 “id<em>“ 类型默认为 “id_autoreleasing</em>“ 类型，所以有必要显式指定为 <code>_strong</code> 修饰符。另外，虽然保证了附有 <code>_strong</code> 修饰符的 id 型变量被初始化为 nil,但并不保证附有 <code>_strong</code> 修饰符的 id 指针型变量被初始化为 nil。</p>
<p>另外，使用类名时如下记述。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSObject</span> * _<span class="keyword">strong</span> *array = <span class="literal">nil</span>;</div></pre></td></tr></table></figure>
<p>其次，使用 <code>calloc</code> 函数确保想分配的附有 <code>_strong</code> 修饰符变量的容量占有的内存块。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">array = (<span class="keyword">id</span> __<span class="keyword">strong</span> *) calloc(entries, <span class="keyword">sizeof</span>(<span class="keyword">id</span>));</div></pre></td></tr></table></figure>
<p>该源代码分配了 <code>entries</code> 个所需的内存块。由于使用附有 <code>_strong</code> 修饰符的变量前必须先将<br>其初始化为 nil，所以这里使用使分配区域初始化为0的 <code>calloc</code> 函数来分配内存。不使用 <code>calloc</code> 函<br>数，在用 <code>malloc</code> 函数分配内存后可用 <code>memset</code> 等函数将内存填充为0。</p>
<p>但是，像下面的源代码这样，将 nil 代入到 malloc 函数所分配的数组各元素中来初始化是非常危险的。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">array = (<span class="keyword">id</span> _<span class="keyword">strong</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">id</span>) * entries);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i * <span class="number">0</span>; i &lt; entries; ++i)</div><div class="line">    array[i] = <span class="literal">nil</span>;</div></pre></td></tr></table></figure>
<p>这是因为由于 malloc 函数分配的内存区域没有被初始化为0，因此 nil 会被赋值给附有 <code>_strong</code> 修饰符的并被赋值了随机地址的变量中，从而释放一个不存在的对象。在分配内存时推荐使用 calloc 函数。</p>
<p>像这样，通过 calloc 函数分配的动态数组就能完全像静态数组一样使用。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">array[<span class="number">0</span>] = [[<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure>
<p>但是，在动态数组中操作附有 <code>_strong</code> 修饰符的变量与静态数组有很大差异，需要自己释放所有的元素。</p>
<p>如以下源代码所示，在只是简单地用 <code>free</code> 函数废弃了数组用内存块的情况下，数组各元素所赋值的对象不能再次释放，从而引起内存泄漏。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">free(array);</div></pre></td></tr></table></figure>
<p>这是因为在静态数组中，编译器能够根据变量的作用域自动插入释放赋值对象的代码，而在动态数组中，编译器不能确定数组的生存周期，所以无从处理。如以下源代码所示，一定要将 nil 赋值给所有元素中，使得元素所赋值对象的强引用失效，从而释放那些对象。在此之后，使用 <code>free</code> 函数废弃内存块。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i * <span class="number">0</span>; i &lt; entries; ++i)</div><div class="line">    array[i] = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">free(array);</div></pre></td></tr></table></figure>
<p>同初始化时的注意事项相反，即使用 memset 等函数将内存填充为0也不会释放所赋值的对象。这非常危险，只会引起内存泄漏。对于编译器，必须明确地使用赋值给附有 <code>_strong</code> 修饰符变量的源代码。所以请注意，必须将 nil 赋值给所有数组元素。</p>
<p>另外，使用 <code>memcpy</code> 函数拷贝数组元素以及 <code>realloc</code> 函数重新分配内存块也会有危险，由于数组元素所赋值的对象有可能被保留在内存中或是重复被废弃，所以这两个函数也禁止使用。</p>
<p>再者，我们也可以像使用 <code>_strong</code> 修饰符那样使用附有 <code>_weak</code> 修饰符变量的动态数组。在 <code>_autoreleasing</code> 修饰符的情况下，因为与设想的使用方法有差异，所以最好不要使用动态数组。由于<code>_unsafe_unretained</code> 修饰符在编译器的内存管理对象之外，所以它与 void* 类型一样，只能作为C语言的指针类型来使用。</p>
<p>本文是根据<a href="https://book.douban.com/subject/24720270/" target="_blank" rel="noopener">Objective-C高级编程</a>第一章整理，作学习和参考之用</p>
<p>关于内存管理可以查看一下唐巧大神博客的讲解：<br><a href="http://blog.devtang.com/2016/07/30/ios-memory-management/" target="_blank" rel="noopener">理解 iOS 的内存管理-唐巧</a></p>


                <div id="rewardContainer">
                  <div></div>
                  <button id="rewardButton" disable="enable" onclick="var qr=document.getElementById('QR'); 'none'===qr.style.display?qr.style.display='block':qr.style.display='none'">
                    <span>赞赏</span>
                  </button>
                  <div id="QR" style="display: none;">
                    <div id="wechat" style="display:inline-block">
                      <img id="wechat_qr" src="/img/wx.png" alt="DIYgod 微信扫一扫，向我赞赏" data-action="zoom">
                      <p>微信扫一扫，向我赞赏</p>
                    </div><div id="alipay" style="display:inline-block">
                      <img id="alipay_qr" src="/img/ali.png" alt="DIYgod 支付宝扫一扫，向我赞赏" data-action="zoom">
                      <p>支付宝扫一扫，向我赞赏</p>
                    </div>
                  </div>
                </div>

                <hr>


                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2017/07/06/iOS-Block/" data-toggle="tooltip" data-placement="top" title="iOS 开发之 Block">&larr; 上一篇</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2017/07/02/Swift-Animation10/" data-toggle="tooltip" data-placement="top" title="Swift CoreAnimation:CATransition 转场动画">下一篇 &rarr;</a>
                        </li>
                    
                </ul>

                

                

                <br/>
                
                    <!-- valine 公共JS代码 start (一个网页只需插入一次) -->
                        <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
                        <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
                    <div id="comment"></div>
                    <script>
                        var notify = false == true ? true : false;
                        var verify = false == true ? true : false;
                        var visitor = false == true ? true : false;
                  new Valine({
                      el: '#comment',
                                notify: notify,
                                verify: verify,
                        enable: 'false'
                        app_id: 'WQIfXvHbniLw45ttBBB3f1KF-gzGzoHsz',
                      app_key: 'E6Jj4yJ5JLhlX5K3QO8AKmXF',
                            placeholder: '快来评论一下吧!',
                            avatar: 'monsterid',
                            pageSize: 10,
                            visitor: visitor
                        });
                </script>
                <!-- valine 公共JS代码 end -->
                

            </div>
    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#ObjC" title="ObjC">ObjC</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="http://mindhacks.cn/" target="_blank">Mind Hacks</a></li>
                    
                        <li><a href="https://onevcat.com/" target="_blank">喵神</a></li>
                    
                        <li><a href="http://mrpeak.cn/" target="_blank">mrpeak</a></li>
                    
                        <li><a href="http://blog.sunnyxx.com/" target="_blank">sunnyxx的技术博客</a></li>
                    
                        <li><a href="https://www.atjason.com/" target="_blank">Jason</a></li>
                    
                        <li><a href="http://blog.devtang.com/" target="_blank">唐巧</a></li>
                    
                        <li><a href="http://blog.ibireme.com/" target="_blank">伽蓝之堂</a></li>
                    
                        <li><a href="http://colachan.com/" target="_blank">可乐橙</a></li>
                    
                        <li><a href="https://www.bmpi.dev/" target="_blank">构建我的被动收入</a></li>
                    
                        <li><a href="https://coolshell.cn/" target="_blank">酷 壳 – CoolShell</a></li>
                    
                        <li><a href="https://tinyfool.org/" target="_blank">Tinyfool&#39;s blog</a></li>
                    
                        <li><a href="https://oldj.net/" target="_blank">oldj&#39;s blog</a></li>
                    
                        <li><a href="https://lutaonan.com/" target="_blank">Randy&#39;s Blog</a></li>
                    
                        <li><a href="https://dbarobin.com/" target="_blank">Cryptospace</a></li>
                    
                        <li><a href="http://kittenyang.com/" target="_blank">Kitten 的时间胶囊</a></li>
                    
                        <li><a href="http://ftqq.com/" target="_blank">方糖气球🎈</a></li>
                    
                        <li><a href="https://www.gatesnotes.com/" target="_blank">GatesNotes</a></li>
                    
                        <li><a href="https://imtx.me/" target="_blank">I&#39;M TUALATRIX</a></li>
                    
                        <li><a href="https://zhowkev.in/" target="_blank">Kevin Blog</a></li>
                    
                        <li><a href="https://blog.forecho.com/" target="_blank">forecho&#39;s Blog</a></li>
                    
                        <li><a href="https://daimajia.com/" target="_blank">代码家</a></li>
                    
                </ul>
                
            </div>

        </div>
    </div>
</article>










    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                    <li>
                        <a href="/atom.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/zhangdinghao">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/zhang-ding-hao">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/CalvinCheungCoder">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    &copy; 2016 -  2021 Calvin, All rights reserved.
					<br>
                    👨🏻‍💻 技术 | 阅读 | 生活
                    <br>
                    <span class="post-count"> 本站共计 160.1k 字 </span>
                    <br>
                    <!-- CNZZ 统计 -->
                    <script type="text/javascript">document.write(unescape("%3Cspan id='cnzz_stat_icon_1279591338'%3E%3C/span%3E%3Cscript src='https://v1.cnzz.com/z_stat.php%3Fid%3D1279591338%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://zhangdinghao.cn/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-104503948-1';
    var _gaDomain = 'null';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?418b76fef727b6da80febf464b8907d3";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<!-- Side Catalog -->





<!-- Image to hack wechat -->
<img src="https://zhangdinghao.cn/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
